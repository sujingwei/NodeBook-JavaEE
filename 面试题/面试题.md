# 一、常见题

## 1、java基础

### 1) JDK、JRE和JVM有什么区别？

**JDK**：Java Development Kit 是Java的标准开发工具包（普通用户只需要安装 JRE来运行 Java 程序。而程序开发者必须安装JDK来编译、调试程序）。它提供了编译、运行Java程序所需的各种工具和资源，包括Java编译器、Java运行环境JRE，以及常用的Java基础类库等，是整个JAVA的核心。

**JRE**：Java runtime environment 是运行基于Java语言编写的程序所不可缺少的运行环境，用于解释执行Java的字节码文件。

**JVM**：Java Virtual Machine 是Java的虚拟机，是JRE的一部分。它是整个java实现跨平台的最核心的部分，负责解释执行字节码文件，是可运行java字节码文件的虚拟计算机。

### 2) == 和 equals 的区别是什么？

- **"=="是比较运算符**，判断两个变量bai或实例du是不是指向zhi同一个内存空间。
- **"equals"是类方法(可重写)**，判断两个变量或实例所指向的内存空间的值是不是相同

### 3) 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗?

答：否。hashCode()和equals没有必然的联系。但重定hashCode或equals需要满足一些规范。

> 1 hashCode和equals返回值应该是稳定的，不应用有随机性
>
> 2 两个对象 == 返回 true，则这两个对象的equals应该返回true
>
> 3 两个对象equals为true，则这两个对象的hashCode应该相等。

反之，两个对象 equals 为 true，两个对象的hashCode() 相等

### 4) final 在 java 中有什么作用?

- 修饰类：表示该类不能被继承；

- 修饰方法：表示方法不能被重写；
- 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。

 ### 5) java 中的 Math.round(-1.5) 等于多少？

四舍五入的原理是在参数上加0.5然后做向下取整，答案：-1

### 6) String 属于基础的数据类型吗？

Java 中 8 种基础的数据类型：byte、short、char、int、long、float、double、boolean

但是 String 类型却是最常用到的引用类型

### 7) java 中操作字符串都有哪些类？它们之间有什么区别？

String、StringBuffer、StringBuilder

**String** : final修饰，String类的方法都是返回new String。即对String对象的任何改变都不影响到原对象，对字符串的修改操作都会生成新的对象。

**StringBuffer** : 对字符串的操作的方法都加了synchronized，保证线程安全。

**StringBuilder** : 不保证线程安全，在方法体内需要进行字符串的修改操作，可以new StringBuilder对象，调用StringBuilder对象的append、replace、delete等方法修改字符串。

### 8) String str="i"与 String str=new String(“i”)一样吗？

`String str="i"`的方式，Java 虚拟机会将其分配到<b style="color:deeppink;">常量池</b>中，而常量池中没有重复的元素，比如当执行`“i”`时，java虚拟机会先在<b style="color:deeppink;">常量池</b>中检索是否已经有`“i”`,如果有那么就将`“i”`的<b style="color:deeppink;">地址赋给变量</b>，如果没有就创建一个，然后在赋给变量；而 `String str = new String(“i”)` 则会被分到<b style="color:deeppink;">堆内存</b>中，<u>即使内容一样还是会创建新的对象</u>。

### 9) 如何将字符串反转？

```java
String str = "abcdefg";
// 方法一
StringBuilder builder = new StringBuilder(str);
System.out.println(builder.reverse());

// 方法二
StringBuilder builder = new StringBuilder();
for(int i=str.length-1; i >= 0; i--){
  builder.append(str.charAt(i))
}
System.out.println(builder.toString());

// 方法三
char[] chars = src.toCharArray();
for (int i = 0; i < chars.length / 2; i++) {
  char tmp = chars[i];
  chars[i] = chars[chars.length-i-1];
  chars[chars.length-i-1] = tmp;
}
System.out.println(new String(chars));
```

### 10) String 类的常用方法都有那些？

* indexOf 返回指定字符的索引
* charAt 返回指定索引处的字符
* replace 字符串替换
* trim 去除字符串两端的空白 
* Split 分割字符串
* getBytes 返回字符串的byte类型数组
* Substring 字符串截取
* equals 字符串比较
* length 字符串长度
* toLowerCase 转小写
* toUpperCase 转大写

### 11) 抽象类必须要有抽象方法吗？

不是必须的。

1. 抽象类必须有关键字abstract来修饰。
2. 抽象类可以不含有抽象方法
3. 如果一个类包含抽象方法，则该类必须是抽象类

### 12) 普通类和抽象类有哪些区别？

1. 抽象类不能被实例化
2. 抽象类可以有抽象方法，抽象方法只需声明，不用实现
3. 含有抽象方法的类型必须声明为抽象类
4. 抽象类的子类必须实现抽象方法，否则类的子类也是抽象类
5. 抽象方法不能用private修饰
6. 抽象方法不能使用final修饰
7. 抽象方法不能声明为静态

### 13) 接口和抽象类有什么区别？

1. 抽象类要被子类继承，接口要被类实现。

2. 接口只能做方法声明，抽象类中可以作方法声明，也可以做方法实现。

3. 接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。

4. 接口是设计的结果，抽象类是重构的结果。

5. 抽象类和接口都是用来抽象具体对象的，但是接口的抽象级别最高。

6. 抽象类可以有具体的方法和属性，接口只能有抽象方法和不可变常量。

7. 抽象类主要用来抽象类别，接口主要用来抽象功能。

### 14) java 中 IO 流分为几种？

- 按照流的流向分，可以分为输入流和输出流；
- 按照操作单元划分，可以划分为字节流和字符流；
- 按照流的角色划分为节点流和处理流。

### 15) Files的常用方法都有哪些？

- exists 判断文件是否存在
- createDirectory 创建目录
- copy 复制文件
- move  移动文件
- delete 删除文件
- deleteIfExists 删除一个文件或目录(空目录)，如果存在就删除

### 16) BIO、NIO、AIO 有什么区别？

**BIO(同步并阻塞)**，<b style="color:deeppink;">服务器实现模式为一个连接一个线程</b>，即客户端连接请求时服务端就需要启动一个线程来处理，如果这个连接不做任何事会造成不必要的线程开销，当然可以通过线程池机制改善。<i style="color:deepskyblue;">线程发起IO请求，不管内核是否准备好IO操作，从发起请求起，线程一直阻塞，直到操作完成</i>。

**NIO(同步非阻塞)**，<b style="color:deeppink;">服务器实现模式为一个请求一个线程</b>，即客户端发送的连接请求会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。<i style="color:deepskyblue;">线程发起IO请求，立即返回；内核在做好IO操作的准备之后，通过调用注册的回调函数通知线程做IO操作，线程开始阻塞，直到操作完成</i>。

**AIO(异步非阻塞)**，<b style="color:deeppink;">服务器实现模式为一个有效请求一个线程</b>，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。<i style="color:deepskyblue;">线程发起IO请求，立即返回；内存做好IO操作的准备之后，做IO操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做IO操作完成或者失败</i>。

## 2、容器

### 1) java 集合都有哪些？

* Collection
  * List
    * ArrayList
    * LinkedList
    * Stack (线程安全)
    * Vector (线程安全)
  * Set
    * HashSet
      * 不能保证元素的排序，顺序有可能发生变化、、
      * 不是同步的
      * 集合同步
      * 集合无素可以是null但只能放入一个null
    * TreeSet
    * LinkedHashSet
* Map
  * HashMap
  * HashTable
  * ConcurrentHashMap (线程安全)
  * TreeMap

### 2) Collection 和 Collections 有什么区别？

- **Collection**是集合体系的最顶层，包含了集合体系的共性

- **Collections**是一个工具类，方法都是用于操作**Collection**

**collections**的常用方法如下：

- sort 排序
- max 集合中的最大值
- reverse 反转元素的顺序
- shuffle 随机排序

### 3) List、Set、Map 之间的区别是什么？

**List**：有序集合

**Set**：不重复集合，LinkedHashSet按照插入排序，SortedSet可排序，HashSet无序

**Map**：键值对集合

### 4) HashMap 和 Hashtable 有什么区别？

#### (1)、继承的父类不同

HashMap 和 HashTable继承的父类不一样，HashMap继承`AbstractMap`而HashTable继承自`Dictionary`。但它们都实现了`Map`、`Cloneable（可复制）`、`Serializable（可序列化）`这三个接口。

#### (2)、对外提供的接口不同

Hashtable比HashMap多提供了`elments()` 和`contains()` 两个方法。

elments() 方法继承自Hashtable的父类`Dictionnary`。elements() 方法用于返回此Hashtable中的value的枚举。

contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue() 就只是调用了一下contains() 方法。

#### (3)、对Null key 和Null value的支持不同

- **HashTable**既不支持Null key也不支持Null value。Hashtable的put()方法的注释中有说明。
- **HashMap**中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。

#### (4)、线程安全性不同

<b style="color:deeppink;">Hashtable是线程安全的</b>，它的每个方法中都加入了Synchronize方法。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步。

<b style="color:deeppink;">HashMap不是线程安全的</b>，在多线程并发的环境下，可能会产生死锁等问题。具体的原因在下一篇文章中会详细进行分析。使用HashMap时就必须要自己增加同步处理。

当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为<b style="color:deeppink;">ConcurrentHashMap使用了分段锁</b>，并不对整个数据进行锁定。

#### (5)、遍历方式的内部实现上不同

Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。

#### (6)、初始容量大小和每次扩充容量大小的不同

- **HashTable**默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。

- **HashMap**默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。

#### (7)、计算hash值的方法不同

**HashTable**直接使用对象的hashCode。hashCode是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数发来获得最终的位置。

**HashMap**为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。

### 5) 如何决定使用 HashMap 还是 TreeMap？

- `TreeMap<K,V>`的Key值是要求实现`java.lang.Comparable`，所以迭代的时候TreeMap默认是按照Key值升序排序的；**TreeMap的实现是基于红黑树结构**。适用于按自然顺序或自定义顺序遍历键（key）。

- `HashMap<K,V>`的Key值实现散列`hashCode()`，分布是散列的、均匀的，不支持排序；**数据结构主要是桶(数组)，链表或红黑树**。适用于在Map中插入、删除和定位元素。

  > 如果你需要得到一个有序的结果时就应该使用TreeMap（因为HashMap中元素的排列顺序是不固定的）。除此之外，由于HashMap有更好的性能，所以大多不需要排序的时候我们会使用HashMap。

### 6) 说一下 HashMap 的实现原理?

HashMap基于<b style="color:deeppink;">hashing原理</b>，我们通过put()和get()方法存储和获取对象。当我们将键值传递给put()方法时，它调用键对象的hashCode()方法来计算hashCode，然后找到bucket位置来储存对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回对象。<u>HashMap使用链表来解决碰撞问题，当发生碰撞，对象将会储存在链表的下一个节点中</u>。HashMap在每个链表节点中储存键值对象。

### 7) 说一下 HashSet 的实现原理?

<b style="color:deeppink;">HashSet实际上是一个HashMap实例，都是一个存放链表的数组</b>。它不保证存储元素的迭代顺序；此类允许使用null元素。HashSet中不允许有重复元素，因为HashSet是基于HashMap实现的，<b style="color:deeppink;">HashSet中的元素都存放在HashMap的key上面</b>，而value中的值都是统一的一个固定对象`private static final Object PRESENT = new Object()`。

HashSet中add方法调用的是底层HashMap中的put()方法，而如果是在HashMap中调用put，首先会判断key是否存在，如果key存在则修改value值，如果key不存在这插入这个key-value。而在set中，因为value值没有用，也就不存在修改value值的说法，因此往HashSet中添加元素，首先判断元素（也就是key）是否存在，如果不存在这插入，如果存在着不插入，这样HashSet中就不存在重复值。

 所以判断key是否存在就要重写元素的类的equals()和hashCode()方法，当向Set中添加对象时，首先调用此对象所在类的hashCode()方法，计算次对象的哈希值，此哈希值决定了此对象在Set中存放的位置；若此位置没有被存储对象则直接存储，若已有对象则通过对象所在类的equals()比较两个对象是否相同，相同则不能被添加。

### 8) ArrayList 和 LinkedList 的区别是什么？

#### (1) 数组结构不同

ArrayList是Array(动态数组)的数据结构，LinkedList是Link(链表)的数据结构。

#### (2) 效率不同

当随机访问List（get和set操作）时，ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。

当对数据进行增加和删除的操作(add和remove操作)时，LinkedList比ArrayList的效率更高，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。

#### (3) 自由性不同

ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。

#### (4) 主要控件开销不同

ArrayList主要控件开销在于需要在lList列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。

### 9) 如何实现数组和 List 之间的转换？

数组转List

```java
String[] strs = new String[] {"aaa", "bbb", "ccc"};
List<String> list = Arrays.asList(strs);
```

List转数组

```java
List<String> list = Arrays.asList("aaa", "bbb", "ccc");
String[] array = list.toArray(new String[list.size()]);
```

### 10) ArrayList 和 Vector 的区别是什么？

1. Vector是线程安全的，ArrayList不是线程安全的。
2. ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。

### 11) Array 和 ArrayList 有何区别？

1. 内存使用上，Array固定长度、ArrayList动态扩容
2. 操作上，ArrayList可使用面向对象的方式对它本身进行操作，而Array不可以
3. 明确数组长度，可以使用Array，否则使用ArrayList

### 12) 在 Queue 中 poll()和 remove()有什么区别？

poll() ，如果队列为空的时候，则会抛出异常

而remove(）只会返回null

### 13) 哪些集合类是线程安全的？

**Vector**：就比Arraylist多了个同步化机制（线程安全）。

**HashTable**：就比Hashmap多了个线程安全。

**ConcurrentHashMap**:是一种高效但是线程安全的集合。

**Stack**：栈，也是线程安全的，继承于Vector。

### 14) 迭代器 Iterator 是什么？

在Java中，有很多的数据容器，对于这些的操作有很多的共性。Java采用了迭代器来为各种容器提供了公共的操作接口。<u>这样使得对容器的遍历操作与其具体的底层实现相隔离</u>，达到解耦的效果。

### 15) Iterator 怎么使用？有什么特点？

Java中的Iterator功能比较简单，并且只能单向移动：

1. 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。

2. 使用next()获得序列中的下一个元素。

3. 使用hasNext()检查序列中是否还有元素。

4. 使用remove()将迭代器新返回的元素删除。

### 16) Iterator和ListIterator区别？

1. ListIterator有add()方法，可以向List中添加对象du，而Iterator不能zhi
2. ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向dao后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。
3. ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。
4. 都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。

### 17) 怎么确保一个集合不能被修改？

我们很容易想到用final关键字进行修饰，我们都知道final关键字可以修饰类，方法，成员变量，final修饰的类不能被继承，final修饰的方法不能被重写，final修饰的成员变量必须初始化值，如果这个成员变量是基本数据类型，表示这个变量的值是不可改变的，如果说这个成员变量是引用类型，则表示这个引用的地址值是不能改变的，但是这个引用所指向的对象里面的内容还是可以改变的。

那么，我们怎么确保一个集合不能被修改？<b style="color:deeppink;">首先我们要清楚，集合（map,set,list…）都是引用类型，所以我们如果用final修饰的话，集合里面的内容还是可以修改的</b>。

我们可以做一个实验：

可以看到：我们用final关键字定义了一个map集合，这时候我们往集合里面传值，第一个键值对1,1；我们再修改后，可以把键为1的值改为100，说明我们是可以修改map集合的值的。

那我们应该怎么做才能确保集合不被修改呢？
我们可以采用`Collections`包下的`unmodifiableMap`方法，通过这个方法`返回的map`,是不可以修改的。他会报 java.lang.UnsupportedOperationException错。

同理：Collections包也提供了对list和set集合的方法。
`Collections.unmodifiableList(List)`
`Collections.unmodifiableSet(Set)`

## 3、多线程

### 1) 并行和并发有什么区别？

并行：同一时刻，有多个任务在执行

并发：同一时刻，处理多少任务

### 2) 线程和进程的区别？

<b style="color:deeppink;">进程是资源分配的最小单位，线程是CPU调度的最小单位。</b>

- 一个进程可以包含多个线程
- 线程共可以共享数据，进线间无法共享数据
- 线程和进程是同生共死的
- 线程在使用的内存地址上可以上锁，表示其它线程需要等到它结束才可以访问。

### 3) 守护线程是什么？

**java的线程分为两种：**

- **用户线程**(普通线程)，就是应用程序里自定义的线程
- **守护线程**，比如说垃圾回收线程，就是最典型的守护线程。

**什么是守护线程？**

1. 守护线程，专门用于服务其他的线程，如果其他的线程（即用户自定义线程）都执行完毕，连main线程也执行完毕，那么jvm就会退出（即停止运行）——此时，连jvm都停止运行了，守护线程当然也就停止执行了。

2. 再换一种说法，如果有用户自定义线程存在的话，jvm就不会退出——此时，守护线程也不能退出，也就是它还要运行，干嘛呢，就是为了执行垃圾回收的任务啊。
3. 守护线程又被称为“服务进程”“精灵线程”“后台线程”，是指在程序运行是在后台提供一种通用的线程，这种线程并不属于程序不可或缺的部分。 通俗点讲，任何一个守护线程都是整个JVM中所有非守护线程的“保姆”。

**怎么创建守护线程?**

```java
Thread t = new Thread() {
  public void run() {
    // .....
  }
}
//setDaemon(true) 必须在 start() 之前设置，否则会抛出IllegalThreadStateException异常，该线程仍默认为用户线程，继续执行
t.setDaemon(true);
t.start();
```

### 4) 创建线程有哪几种方式?

#### (1) 第一种，通过继承Thread类创建线程类

```java
public class ExtendThread extends Thread {
	private int i;
	public static void main(String[] args) {
		for(int j = 0;j < 50;j++) {	
			//调用Thread类的currentThread()方法获取当前线程
			System.out.println(Thread.currentThread().getName() + " " + j);
			if(j == 10) {
				//创建并启动第一个线程
				new ExtendThread().start();
				//创建并启动第二个线程
				new ExtendThread().start();
			}
		}
	}
 
	public void run() {
		for(;i < 100;i++) {
			//当通过继承Thread类的方式实现多线程时，可以直接使用this获取当前执行的线程
			System.out.println(this.getName() + " "  + i);
		}
	}
}
```

#### (2) 第二种，通过实现Runnable接口创建线程类

```java
public class ImpRunnable implements Runnable {
	private int i;
	@Override
	public  void run() {
		for(;i < 50;i++) {	
			//当线程类实现Runnable接口时，要获取当前线程对象只有通过Thread.currentThread()获取
			System.out.println(Thread.currentThread().getName() + " " + i);
		}
	}
	public static void main(String[] args) {
		for(int j = 0;j < 30;j++) {
			System.out.println(Thread.currentThread().getName() + " " + j);
			if(j == 10) {
				ImpRunnable thread_target = new ImpRunnable();
				//通过new Thread(target,name)的方式创建线程
				new Thread(thread_target,"线程1").start();
				new Thread(thread_target,"线程2").start();
			}	
		}
	}
}
```

#### (3) 通过Callable和Future接口创建线程

##### A、Callable

Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法call()，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。

```java
public interface Callable<V> {
    V call() throws Exception;
}
```

Callable要采用ExecutorSevice的`submit`方法提交，而不是execute方法，因为execute方法没有返回值，在ExecutorService接口中有若干个submit方法的重载版本。

```java
<T> Future<T> submit(Callable<T> task);
<T> Future<T> submit(Runnable task, T result);
Future<?> submit(Runnable task);
```

第一个submit方法里面的参数类型就是Callable。

##### B、Future

Future是一个接口，它可以对Callable任务的执行结果进行操作。可以说Future提供了三种功能：<b style="color:deeppink;">判断任务是否完成；能够中断任务；能够获取任务执行结果</b>。

- **cancel()** 方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。

- **isCancelled()**方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。

- **isDone()**方法表示任务是否已经完成，若任务完成，则返回true；

- **get()**方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；

- **get(long timeout, TimeUnit unit)**用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。

```java
 
public class AtomicIntegerFieldUpdaterTest {
	public static <T> void main(String[] args) {
		ExecutorService newFixedThreadPool = Executors.newSingleThreadExecutor();
		Future<String> submit = newFixedThreadPool.submit(new Callable<String>() {
			@Override
			public String call() throws Exception {
				// TODO Auto-generated method stub
				return "我是生产的结果";
			}
		});
    // 在这里，主线程可以完成别的工作 .......
		try {
      //  get 方法会阻塞
			System.out.println("我来拿结果了："+submit.get());
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (ExecutionException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
```

### 5) 说一下 Runnable 和 Callable 有什么区别？

**相同点**

1、两者都是接口；（废话）
 2、两者都可用来编写多线程程序；
 3、两者都需要调用Thread.start()启动线程；

**不同点**

1、两者最大的不同点是：实现Callable接口的任务线程能返回执行结果；而实现Runnable接口的任务线程不能返回结果；
 2、Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛；

**注意点**

Callable接口支持返回执行结果，此时需要调用FutureTask.get()方法实现，此方法会阻塞主线程直到获取‘将来’结果；当不调用此方法时，主线程不会阻塞！

<b>ExcutorService中的excutor和submit方法的区别</b>

两者都是将一个线程任务添加到线程池中并执行；
 1、excutor没有返回值，submit有返回值，并且返回执行结果Future对象
 2、excutor不能提交Callable任务，只能提交Runnable任务，submit两者任务都可以提交
 3、在submit中提交Runnable任务，会返回执行结果Future对象，但是Future调用get方法将返回null（Runnable没有返回值）

### 6) 线程有哪些状态？

线程状态有 6 种，关系图如下：

![java线程状态](http://notebook-1.aoae.top/15977222621755)

**NEW:新建状态**，线程已创建，但没启动(还没有调用start()方法)

**RUNNABLE:就绪状态**，可运行状态，调用了线程的start方法，已经在java虚拟机中执行，等待获取操作系统资源如CPU，操作系统调度运行。

**BLOCKED:堵塞状态**，线程等待锁的状态，等待获取锁进入同步块/方法或调用wait后重新进入需要竞争锁。

**WAITING:等待状态**，等待另一个线程以执行特定的操作。调用以下方法进入等待状态。 Object.wait(), Thread.join(),LockSupport.park。

**TIMED_WAITING:超时等待状态**，线程等待一段时间。调用带参数的Thread.sleep, objct.wait,Thread.join，LockSupport.parkNanos,LockSupport.parkUntil。

**TERMINATED:进程结束状态**

### 7) sleep() 和 wait() 有什么区别？

1. 两个方法来自不同的类分别是Thead和Object，sleep方法属于Thread类中静态方法;wait方法属于Object类的方法。
2. sleep() 不涉及线程通信，调用时会暂停此线程指定的时间，但监控依然保，<b style="color:deeppink;">不会释放对象锁</b>，到时间自动恢复；wait()用于线程间通信，调用时会<b style="color:deeppink;">放弃对象锁，进入等待队列</b>，调用`notify()/notifyAll()`唤醒指定的线程或者所有线程，<u>才进入对象锁定池准备获取对象锁进入运行状态</u>。
3. wait，notify和notifyAll只能在**同步控制方法**或者**同步控制块**里面使用，而sleep可以在任何地方使用（使用范围）.
4. sleep()方法必须捕获异常InterruptedException，而wait()\notify()以及notifyAll()不需要捕获异常。

### 8) notify()和 notifyAll()有什么区别？

**notify()**，随机唤醒一个处于等待状态的线程；要唤醒的是哪个，由JVM决定。

**notifyAll()**，唤醒所有处入等待状态的线程; 并可以理解为把他们排进一个队列；这些线程会进入对对象锁池中竞争对象锁，只有获取到锁后才真正被被唤醒，进入RUNNABLE状态。

### 9) 线程的 run()和 start()有什么区别？

- 启动一个线程需要调用 Thread 对象的 start() 方法
- 调用线程的 start() 方法后，线程处于可运行状态，此时它可以由 JVM 调度并执行，这并不意味着线程就会立即运行
- run() 方法是线程运行时由 JVM 回调的方法，无需手动写代码调用
- 直接调用线程的 run() 方法，相当于在调用线程里继续调用方法，并未启动一个新的线程

### 10) 创建线程池有哪几种方式？

Java通过`Executors`提供四种线程池，分别为：

| 类                                | 描述                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| Executors.newCachedThreadPool     | <b style="color:deeppink;">可缓存线程池</b>，如果线程池长度处理需要，可灵活回收空闲线程，若无可回收线程，则新建线程 |
| Executors.newFixedThreadPool      | <b style="color:deeppink;">定长线程池</b>，可控制线程最大并发数，超出的线程会在队列中等待。 |
| Executors.newSingleThreadExecutor | <b style="color:deeppink;">单线程化的线程池</b>，它只会用唯一的工作线程来执行任务，保证所有任务按照顺序(FIFO，LIFO，优化级)执行。 |
| Executors.newScheduledThreadPool  | <b style="color:deeppink;">定长线程池</b>，支持定时及周期性任务执行。 |

我们也可以通过`ThreadPoolExecutor`手动创建线程池：

```java
new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds, runnableTaskQueue, threadFactory, handler)
```

参数说明：

| 名称              | 类型                     | 含义                       |
| ----------------- | ------------------------ | -------------------------- |
| corePoolSize      | int                      | 线程池中核心线程数的最大值 |
| maximumPoolSize   | int                      | 线程池中能拥有最多线程数   |
| keepAliveTime     | Long                     | 表示**空闲线程**的存活时间 |
| milliseconds      | TimeUnit                 | 时间单位                   |
| runnableTaskQueue | BlockingQueue<Runnable>  | 用于缓存任务的阻塞队列     |
| threadFactory     | ThreadFactory            | 线程创建工厂               |
| handler           | RejectedExecutionHandler |                            |

**workQueue：**

1. 如果没有空闲的线程执行添加新的任务且当前运行的线程数少于**corePoolSize**，则添加新的线程执行该任务
2. 如果没有空闲的线程执行任务且当前的线程数等于**corePoolSize**同时阻塞队列未满，则将任务入队列，而不添加新的线程
3. 如果没有空闲的线程执行该任务且阻塞队列已满，同时池中的线程数小于**maximumPoolSize**，则创建新的线程执行任务
4. 如果没有空闲的线程执行该任务且阻塞队列已满，同时池中的线程数等于**maximumPoolSize**，则根据构造函数中的**handler**指定的策略来拒绝新的任务。

注意，线程池并没有标记哪个线程是核心线程，哪个是非核心线程，线程池只关心核心线程的数量。

> 在线程池中常用的阻塞队列有以下2种：
>
> SynchronousQueue<Runnable>：无界队列
>
> LinkedBlockingQueue<Runnable>：有界队列

**keepAliveTime**

为了解释keepAliveTime的作用，我们在上述情况下做一种假设。假设线程池这个单位已经招了些临时工，但新任务没有继续增加，所以随着每个员工忙完手头的工作，都来workQueue领取新的任务（看看这个单位的员工多自觉啊）。随着各个员工齐心协力，任务越来越少，员工数没变，那么就必定有闲着没事干的员工。这样的话领导不乐意啦，但是又不能轻易fire没事干的员工，因为随时可能有新任务来，于是领导想了个办法，设定了keepAliveTime，当空闲的员工在keepAliveTime这段时间还没有找到事情干，就被辞退啦，毕竟地主家也没有余粮啊！当然辞退到corePoolSize个员工时就不再辞退了，领导也不想当光杆司令啊！

**handler**

假设线程池这个单位招满临时工，但新任务依然继续增加，线程池从上到下，从里到外真心忙的不可开交，阻塞队列也满了，只好拒绝上级委派下来的任务。怎么拒绝是门艺术，handler一般可以采取以下四种取值

| 拒绝策略                                 | 描述                                         |
| ---------------------------------------- | -------------------------------------------- |
| ThreadPoolExecutor.AbortPolicy()         | 抛出RejectedExceptionException异常           |
| ThreadPoolExecutor.CallerRunsPolicy()    | 由向线程池提交任务的线程来执行该任务         |
| ThreadPoolExecutor.DiscardOldestPolicy() | 抛弃最旧的任务(最先提交而没有得到执行的任务) |
| ThreadPoolExecutor.DiscardPolicy()       | 抛弃当前任务                                 |

### 11) 线程池都有哪些状态？

|状态|描述|
| ---------- | ------------------------------------------------------------ |
| RUNNING    | 允许提交并处理任务                                           |
| SHUTDOWN   | 不允许提交新的任务，但是会处理完已提交的任务                 |
| STOP       | 不允许提交新的任务，也不会处理阻塞队列中未执行的任务，并设置正在执行的线程的中断标志位 |
| TIDYING    | 所有任务执行完毕，池中工作的线程数为0，等待执行terminated()勾子方法 |
| TERMINATED | terminated()勾子方法执行完毕                                 |

### 12) 线程池中 submit()和 execute()方法有什么区别?

1. execute() 参数 Runnable ；submit() 参数 (Runnable) 或 (Runnable 和 结果 T) 或 (Callable)
2. execute() 没有返回值；而 submit() 有返回值
3. submit() 的返回值 Future 调用get方法时，可以捕获处理异常

### 13) 在 java 程序中怎么保证多线程的运行安全？

**线程的安全性问题体现在**：

**原子性**：一个或多个操作在cpu执行的过程中不被中断的特性

**可见性**：一个线程对共享变量的修改，另一个线程能够立刻看到

**有序性**：程序执行的顺序按照代码先后顺序执行

**导致原因：**

- 缓存导致的可见性问题

- 线程切换带来的原子性问题

- 编译优化带来的有序性问题

**解决办法：**

- JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题
- synchronized、volatile、LOCK，可以解决可见性问题
- Happens-Before 规则可以解决有序性问题

### 14) 多线程锁的升级原理是什么？

**锁的级别从低到高**：

无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁

**锁分级别原因**：

没有优化以前，synchronized是重量级锁（悲观锁），使用 wait 和 notify、notifyAll  来切换线程状态非常消耗系统资源；线程的挂起和唤醒间隔很短暂，这样很浪费资源，影响性能。所以 JVM 对 synchronized  关键字进行了优化，把锁分为 `无锁`、`偏向锁`、`轻量级锁`、`重量级锁` 状态。

**无锁**：没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功，其他修改失败的线程会不断重试直到修改成功。

**偏向锁**：对象的代码一直被同一线程执行，不存在多个线程竞争，该线程在后续的执行中自动获取锁，降低获取锁带来的性能开销。偏向锁，指的就是偏向第一个加锁线程，该线程是不会主动释放偏向锁的，只有当其他线程尝试竞争偏向锁才会被释放。

偏向锁的撤销，需要在某个时间点上没有字节码正在执行时，先暂停拥有偏向锁的线程，然后判断锁对象是否处于被锁定状态。如果线程不处于活动状态，则将对象头设置成无锁状态，并撤销偏向锁；

如果线程处于活动状态，升级为轻量级锁的状态。

**轻量级锁**：轻量级锁是指当锁是偏向锁的时候，被第二个线程 B 所访问，此时偏向锁就会升级为轻量级锁，线程 B 会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。

当前只有一个等待线程，则该线程将通过自旋进行等待。但是当自旋超过一定的次数时，轻量级锁便会升级为重量级锁；当一个线程已持有锁，另一个线程在自旋，而此时又有第三个线程来访时，轻量级锁也会升级为重量级锁。

**重量级锁**：指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态。

重量级锁通过对象内部的监视器（monitor）实现，而其中 monitor 的本质是依赖于底层操作系统的 Mutex Lock 实现，操作系统实现线程之间的切换需要从用户态切换到内核态，切换成本非常高。

### 15) 什么是死锁？

死锁是指两个或两个以上的**进程/线程**在执行过程中，<b style="color:deeppink;">由于竞争资源或者由于彼此通信</b>而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的**进程/线程**称为死锁进程

### 16) 怎么防止死锁？

1. 加锁顺序(线程按照一定的顺序加锁)
2. 加锁时限(线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁)
3. 死锁检测

### 17) ThreadLocal 是什么？有哪些使用场景？

ThreadLocal 是线程本地存储，在每个线程中都创建了一个 ThreadLocalMap 对象，每个线程可以访问自己内部 ThreadLocalMap 对象内的 value。

经典的使用场景是为每个线程分配一个 JDBC 连接 Connection。这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection； 还有 Session 管理 等问题。

**实现原理：**

JDK 的实现里面这个 Map 是属于 Thread，而非属于 ThreadLocal。ThreadLocal 仅是一个代理工具类，内部并不持有任何与线程相关的数据，所有和线程相关的数据都存储在 Thread 里面。ThreadLocalMap 属于 Thread 也更加合理。

还有一个更加深层次的原因，这样设计不容易产生内存泄露。
ThreadLocal 持有的 Map 会持有 Thread 对象的引用，只要 ThreadLocal 对象存在，那么 Map 中的 Thread 对象就永远不会被回收。ThreadLocal 的生命周期往往比线程要长，所以这种设计方案很容易导致内存泄露。
JDK 的实现中 Thread 持有 ThreadLocalMap，而且 ThreadLocalMap 里对 ThreadLocal 的引用还是弱引用（WeakReference），所以只要 Thread 对象可以被回收，那么 ThreadLocalMap 就能被回收。JDK 的这种实现方案复杂但更安全。

### 18) 说一下 synchronized 底层实现原理？

如果对上面的执行结果还有疑问，也先不用急，我们先来了解Synchronized的原理，再回头上面的问题就一目了然了。我们先通过反编译下面的代码来看看Synchronized是如何实现对代码块进行同步的：

```java
 package com.paddx.test.concurrent;
 
 public class SynchronizedDemo {
     public void method() {
         synchronized (this) {
             System.out.println("Method 1 start");
         }
     }
 }
```

反编译结果：

![](http://notebook-1.aoae.top/15977223176875)

关于这两条指令的作用，我们直接参考JVM规范中描述

```
monitorenter ：
Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:
• If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.
• If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.
• If another thread already owns the monitor associated with objectref, the thread blocks until the monitor's entry count is zero, then tries again to gain ownership.
```

这段话的大概意思为：

每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：

1. 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。

2. 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.

3. 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。

**总结：**

> synchronized是jvm实现的一种互斥同步访问方式，底层是基于每个对象的监视器(monitor)来实现的。被synchronized修饰的代码，在被编译器编译后在被修饰的代码前后加上了一组字节指令。
>
> 在代码开始加入了monitorenter，在代码后面加入了monitorexit，这两个字节码指令配合完成了synchronized关键字修饰代码的互斥访问。
>
> 在虚拟机执行到monitorenter指令的时候，会请求获取对象的monitor锁，基于monitor锁又衍生出一个锁计数器的概念。
>
> 当执行monitorenter时，若对象未被锁定时，或者当前线程已经拥有了此对象的monitor锁，则锁计数器+1，该线程获取该对象锁。
>
> 当执行monitorexit时，锁计数器-1，当计数器为0时，此对象锁就被释放了。那么其他阻塞的线程则可以请求获取该monitor锁。

### 19) synchronized 和 volatile 的区别是什么？

> volatile关键字的作用
>
> 保证了变量的可见性（visibility）。被volatile关键字修饰的变量，如果值发生了变更，其他线程立马可见，避免出现脏读的现象

1. volatile只能作用于变量，使用范围较小。synchronized可以用在变量、方法、类、同步代码块等，使用范围比较广。 
2. volatile只能保证可见性和有序性，不能保证原子性。而可见性、有序性、原子性synchronized都可以包证。 
3. volatile不会造成线程阻塞。synchronized可能会造成线程阻塞。

### 20) synchronized 和 Lock 有什么区别？

#### (1)、原始构成

Synchronized关键字属于JVM层面，底层通过monitor对象来完成(wait/notify 等方法也依赖于 monitor 对象只有在同步块或方法中才能调 wait/notify 等方法)

Lock是`java.util.concurrent.locks`包下的类

#### (2)、使用方式

Synchronized不需要用户手动释放锁，当Synchronized代码执行完成后会自动释放锁

Lock需要lock()和unlock()方法，并配置try/finally语句来完成

#### (3)、等待是否可中断

synchronized不可中断，除非抛出异常或正常运行完成

Lock可中断，(1)、设置超时方法 tryLock(long timeout, TimeUnit unit)；(2)、ockInterruptibly() 放代码块中, 调用 interrupt() 方法可中断

#### (4)、加锁是否公平

synchronized非公平锁

Lock在构造方法中传入true表示公平锁

#### (5)、唤醒

ockInterruptibly() 放代码块中, 调用 interrupt() 方法可中断

ReentrantLock 用来实现分组唤醒需要唤醒的线程们

### 21) synchronized 和 ReentrantLock 区别是什么？

1. Synchronized竞争锁时会一直等待，ReentrantLock可以尝试获取锁，并得到获取结果
2. synchronized获取锁无法设置超时，ReentrantLock可以设置获取锁的超时时间
3. Synchronized无法实现公平锁，ReentrantLock可以获取公平锁；<b style="color:deeppink;">就是先等待，先获取取锁</b>。
4. Synchronized等待和唤醒需要结合wait()和notify()、notifyAll()；ReentrantLock 控制等待和唤醒需要结合await()和signal()、signalAll ()方法
5. synchronized 是JVM层面实现的；ReentrantLock 是 JDK 代码层面实现
6. synchronized出现异常会自动释放锁；ReentrantLock 不会自动释放锁，需要通过finally来释放

### 22) 说一下 atomic 的原理？

答：<b>如何保证原子性：<span style="color:deeppink;">自旋 + CAS（乐观锁）</span></b>。

查看一下AtomicInteger的代码

![自旋 + CAS(乐观锁)](http://notebook-1.aoae.top/15977273109404)

如何保证原子性：**自旋 + CAS（乐观锁）**。在这个过程中，通过compareAndSwapInt比较更新value值，如果更新失败，重新获取旧值，然后更新。

优缺点：

**CAS**相对于其他锁，不会进行内核态操作，有着一些性能的提升。但同时引入自旋，<i style="color:blue;">当锁竞争较大的时候，自旋次数会增多。cpu资源会消耗很高</i>。

换句话说，CAS+自旋适合使用在低并发有同步数据的应用场景。

### 23) 什么是CAS?

CAS是英文单词`Compare and Swap`的缩写，翻译过来就是比较并替换。

CAS机制中使用了3个基本操作数：内存地址`V`，旧的预期值`A`，要修改的新值`B`。

<b style="color:deeppink;">更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B</b>。

## 4、反射

### 1) 什么是反射？

Java的反射（reflection）机制是指在程序的运行状态中，可以构造任意一个类的对象，可以了解任意一个对象所属的类，可以了解任意一个类的成员变量和方法，可以调用任意一个对象的属性和方法。这种动态获取程序信息以及动态调用对象的功能称为Java语言的反射机制。

### 2) 什么是 java 序列化？什么情况下需要序列化？

序列化：将 Java 对象转换成字节流的过程。

反序列化：将字节流转换成 Java 对象的过程。

当 Java 对象需要在网络上传输 或者 持久化存储到文件中时，就需要对 Java 对象进行序列化处理。

序列化的实现：类实现 Serializable 接口，这个接口没有需要实现的方法。实现 Serializable 接口是为了告诉 jvm 这个类的对象可以被序列化。

### 3) 动态代理是什么？有哪些应用？

### 4) 怎么实现动态代理？

## 5、对象拷贝

### 1) 为什么要使用克隆？

想要对一个对象进行处理，又想保留原有的数据的时候，就需要克隆。克隆分有**浅克隆**和**深克隆**。

**浅克隆**：复制对象时仅仅复制对象本身，包括基本属性，但该对象的属性引用其他对象时，该引用对象不会被复制，<i style="color:blue;">即拷贝出来的对象与被拷贝出来的对象中的属性引用的对象是同一个</i>。

**深克隆**：复制对象本身的同时，也复制对象包含的引用指向的对象，<i style="color:blue;">即修改被克隆对象的任何属性都不会影响到克隆出来的对象</i>。

### 2) 如何实现对象克隆？

**浅克隆：**

```java
// 实现 Cloneable 接口
class Person implements Cloneable{

    private int age;
    private String name;

    public Person(int age, String name) {
        this.age = age;
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Person{" +
                "age=" + age +
                ", name='" + name + '\'' +
                '}';
    }
		/** 重写 clone 方法*/
    @Override
    protected Object clone() throws CloneNotSupportedException {  
        return super.clone();   //调用父类的clone方法
    }
}
```

**深克隆：**

```java
class Student implements Cloneable{
  private Address address; // 引用类型
	@Override
	protected Object clone() throws CloneNotSupportedException {
        Student obj =  super.cloe();
    		// 引用类型也使用克隆对象
				obj.Address = (Address)address.close()
        return obj;
	}
```

### 3) 深拷贝和浅拷贝区别是什么？

见上。

## 6、Java WEB

### 1) jsp 和 servlet 有什么区别？

1. jsp经编译后变成Servlet
2. jsp擅长表现于页面显示，Servlet擅长于逻辑控制
3. Servlet没有内置对象，它的内置对象需要通过HttpServletRequest或HttpServletResponse得到
4. JSP侧重于视图，可以和HTML组合

### 2) jsp 有哪些内置对象？作用分别是什么？

| 对象名称    | 作用域             | 描述                       |
| ----------- | ------------------ | -------------------------- |
| request     | 当前请求范围       | 客户端请求                 |
| response    |                    | 网页传回用户端回应         |
| pageContext |                    | 网页的属性在这里管理       |
| session     | 会话范围           | 与请求有关会话期           |
| application | 整个应用的生命周期 | servlet正在执行的内容      |
| out         |                    | 用来传送回应的输出         |
| config      |                    | servlet的架构部件          |
| page        | 当前页面范围内     | JSP网页本身                |
| exception   |                    | 针对错误网页，未捕捉的列外 |

### 3) 说一下 jsp 的 4 种作用域？

| 作用域      | 描述           |
| ----------- | -------------- |
| page        | 当前页面作用域 |
| request     | 请求作用域     |
| session     | 会话作用域     |
| Application | 全局作用域     |

### 4) session 和 cookie 有什么区别？

1. SESSION存储在服务器端，COOKIE保存在客户端。SESSION比较安全，COOKIE用某些手段可以修改，不安全。SESSION依赖于COOKIE进行传递。禁用COOKIE后，SESSION不能正常使用。
2. SESSION的缺点：保存在服务器端，每次读取都从服务器进行读取，对服务器有资源消耗。
3. COOKIE的存储量有限、只允许存入4KB，而SESSION是无限量的。COOKIE可以通过javscript来操作，使用起来比较方便。不要将敏感的数据存入COOKIE中，这样是非常不安全的。

### 5) 说一下 session 的工作原理？

当客户端完成特定操作(如登录)后，服务器就会创建session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器(使用cookie)中。这样客户端每次访问服务器时，都会带着 sessionid，服务器拿到 sessionid 之后，在内存找到与之对应的 session 这样就可以正常工作了。

### 6) 如果客户端禁止 cookie 能实现 session 还能用吗？

答：当然--------不能用了
因为服务端是根据session的id来确定当前对话所对应的的服务器，而session id 是通过cookie来传递的，禁用cookie相当于失去了sessionID，也就得不到session了。

### 7) spring mvc 和 struts 的区别是什么？

#### (1)、底层实现机制

struts2:filter

springmvc:servlet

#### (2)、运行效率

struts2:底层是Servlet,参数基于属性封装,如果配置单例,会出现线程安全问题,所以配置多例

springmvc:底层是Servlet,单例

#### (3)、参数封装

struts2:基于属性封装

springmvc:基于方法进行封装

### 8) 如何避免 sql 注入？

1. 严格限制 Web 应用的数据库的操作权限，给连接数据库的用户提供满足需要的最低权限，最大限度的减少注入攻击对数据库的危害
2. 输入校验
3. 对进入数据库的特殊字符进行转义处理，或编码转换
4. 使用预编译 SQL（Java 中使用 PreparedStatement），参数化查询方式，避免 SQL 拼接
5. 发布前，利用工具进行 SQL 注入检测
6. 报错信息不要包含 SQL 信息输出到 Web 页面

### 9) 什么是 XSS 攻击，如何避免？

XSS攻击全称跨站脚本攻击，是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。

**如何防御XSS攻击？**

1. 对输入内容的特定字符进行编码，例如表示 html标记的 < > 等符号。

2. 对重要的 cookie设置 httpOnly, 防止客户端通过document.cookie读取 cookie，此 HTTP头由服务端设置。

3. 将不可信的值输出 URL参数之前，进行 URLEncode操作，而对于从 URL参数中获取值一定要进行格式检测（比如你需要的时URL，就判读是否满足URL格式）。

4. 不要使用 Eval来解析并运行不确定的数据或代码，对于 JSON解析请使用 JSON.parse() 方法。

5. 后端接口也应该要做到关键字符过滤的问题。

### 10) 什么是 CSRF 攻击，如何避免？

跨站(域)请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。

**CSRF的防范措施：**

1. 验证 HTTP Referer 字段

2. 验证码

3. 添加token验证

4. 尽量使用POST，限制GET

### 11) GET和POST有什么区别？

- GET在浏览器回退时是无害的，而POST会再次提交请求。

- GET产生的URL地址可以被Bookmark，而POST不可以。

- GET请求会被浏览器主动cache，而POST不会，除非手动设置。

- GET请求只能进行url编码，而POST支持多种编码方式。

- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

- GET请求在URL中传送的参数是有长度限制的，而POST没有。

- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。

- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

- GET参数通过URL传递，POST放在Request body中。

**深入一点解答：**

GET产生<b>一个</b>TCP数据包；POST产生<b>两个</b>TCP数据包。

> 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
>
> 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

## 7、异常

### 1) throw 和 throws 的区别？

Throw是在方法体内手动抛出的异常，一次只能抛出一个异常，由方法体处理，如果方法体内不处理，则需要在方法上声明throws

Throws是在方法声明时，表明该方法可能产生的所有异常，不做任何直接处理向上层传

### 2) final、finally、finalize 有什么区别？

#### (1)、final ：

1、修饰符（关键字bai） 如果一个类被声du明为final,意味着它不能再zhi派生新的子类，不能作为父类被继承dao。因此一个类不能及被声明为abstract，又被声明为final的。

2、将变量或方法声明为final,可以保证他们使用中不被改变。被声明为final的变量必须在声明时给定初值，而以后的引用中只能读取，不可修改，被声明为final的方法也同样只能使用，不能重载。

#### (2)、finally:

在异常处理时提供finally块来执行清楚操作。如果抛出一个异常，那么相匹配的catch语句就会执行，然后控制就会进入finally块，如果有的话。

#### (3)、finalize：

是方法名。java技术允许使用finalize()方法在垃圾收集器将对象从内存中清除之前做必要的清理工作。这个方法是在垃圾收集器在确定了，被清理对象没有被引用的情况下调用的。

finalize是在Object类中定义的，因此，所有的类都继承了它。子类可以覆盖finalize()方法，来整理系统资源或者执行其他清理工作。

### 3) try-catch-finally 中哪个部分可以省略？

catch 和 finally 语句块可以省略其中一个。

### 4) try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？

不管有没有异常都会执行，在return 前执行

### 5) 常见的异常类有哪些？

- NullPointerException 当应用程序试图访问空对象时，则抛出该异常。
- SQLException 提供关于数据库访问错误或其他错误信息的异常。
- IndexOutOfBoundsException指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 
- NumberFormatException当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。
- FileNotFoundException当试图打开指定路径名表示的文件失败时，抛出此异常。
- IOException当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。
- ClassCastException当试图将对象强制转换为不是实例的子类时，抛出该异常
- ArrayStoreException试图将错误类型的对象存储到一个对象数组时抛出的异常。
- IllegalArgumentException 抛出的异常表明向方法传递了一个不合法或不正确的参数。
- ArithmeticException当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。 
- NegativeArraySizeException如果应用程序试图创建大小为负的数组，则抛出该异常。
- NoSuchMethodException无法找到某一特定方法时，抛出该异常
- SecurityException由安全管理器抛出的异常，指示存在安全侵犯
- UnsupportedOperationException当不支持请求的操作时，抛出该异常。
- RuntimeExceptionRuntimeException 是那些可能在Java虚拟机正常运行期间抛出的异常的超类。

## 8、网络

### 1) http 响应码 301 和 302 代表的是什么？有什么区别？

301：永久重定向；302：暂时重定向。

它们的区别是，301 对搜索引擎优化（SEO）更加有利；302 有被提示为网络拦截的风险。

### 2) forward 和 redirect 的区别？

是servlet种的两种主要的跳转方式。forward又叫转发，redirect叫做重定向。

1. 数据共享

   由于整个定向过程中用的是同一个request，因此forward会将request的信息带到下一个jsp或servlet中使用，可以共享数据。redirect不能共享

   forward url地址没变

   redirect url地址变了

2. 作用

   forword用于转发用户模块

   redirect用于页面跳转

### 3) 简述 tcp 和 udp的区别？

#### UDP 是面向无连接的通讯协议，UDP 数据包括目的端口号和源端信息。
**优点：**UDP 速度快、操作简单、要求系统资源较少，由于通讯不需要连接，可以实现广播发送
**缺点：**UDP 传送数据前并不与对方建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收，也不重复发送，不可靠。

#### TCP 是面向连接的通讯协议，通过三次握手建立连接，通讯完成时四次挥手
**优点**：TCP 在数据传递时，有确认、窗口、重传、阻塞等控制机制，能保证数据正确性，较为可靠。
**缺点：**TCP 相对于 UDP 速度慢一点，要求系统资源较多。

### 4) tcp 为什么要三次握手，两次不行吗？为什么？

#### (1) 三次握手

##### a、第一次握手

客户端发送一个TCP的SYN标志位置1的包指明客户打算连接的服务器的端口，以及初始序号X,保存在包头的序列号(Sequence Number)字段里

![](http://notebook-1.aoae.top/15977428818702)

##### b、第二次握手

服务器发回确认包**(ACK)应答**。即**SYN标志位和ACK标志位均为1**同时，将确认序号(Acknowledgement Number)设置为客户的I S N加1以.即X+1。

![](http://notebook-1.aoae.top/15977429567594)

##### c、第三次握手

客户端再次发送确认包(ACK) SYN标志位为0,**ACK标志位为1**.并且把服务器发来ACK的序号字段+1,放在确定字段中发送给对方.并且在数据段放写ISN的+1

![](http://notebook-1.aoae.top/15977430193505)

#### (2) 四次挥手

所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：

![](http://notebook-1.aoae.top/15977431406450)

由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。
 **第一次挥手：**Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
 **第二次挥手**：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。
 **第三次挥手：**Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
 **第四次挥手：**Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

### 5) 说一下 tcp 粘包是怎么产生的？

引言：TCP协议是网络通信协议中十分重要的协议，相比于UDP协议来说，它是一个可靠的传输协议，并且是一个面向数据流的协议；所谓面向数据流，其实是指数据传输是以流式的方式传输，这些传输的数据就像一条河里的水，他们之间是没有缝隙的，也就是说TCP协议传输的数据是无边界的；（其实TCP粘包概念个人感觉不恰当，毕竟TCP传输是以流式的方式）
而UDP是面向数据包的，收发数据包要么全收要么不收，数据包与数据包之间是有明显的边界的；

#### (1) TCP粘包是什么？

粘包发生在发送或接收缓冲区中；应用程序从缓冲区中取数据是整个缓冲区中有多少取多少；那么就有可能第一个数据的尾部和第二个数据的头部同时存在缓冲区，而TCP是流式的，数据无边界，这时发生粘包。

![](http://notebook-1.aoae.top/15977439617804)

#### (2) TCP粘包的产生

##### a.发送方产生粘包
采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于的小时，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了；

![](http://notebook-1.aoae.top/15977442980802)

##### b.接收方产生粘包
接收方采用TCP协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包；（放数据的速度 > 应用层拿数据速度）

![](http://notebook-1.aoae.top/15977443560391)

#### (3) TCP粘包的解决方案

目前应用最广泛的是在消息的头部添加数据包长度，接收方根据消息长度进行接收；在一条TCP连接上，数据的流式传输**在接收缓冲区里**是有序的，其主要的问题就是第一个包的包尾与第二个包的包头共存接收缓冲区，所以根据长度读取是十分合适的；

##### a.解决发送方粘包
######（1）发送产生是因为Nagle算法合并小数据包，那么可以禁用掉该算法；
######（2）TCP提供了强制数据立即传送的操作指令push，当填入数据后调用操作指令就可以立即将数据发送，而不必等待发送缓冲区填充自动发送；
######（3）数据包中加头，头部信息为整个数据的长度（最广泛最常用）；

##### b.解决接收方粘包
######（1）解析数据包头部信息，根据长度来接收；
######（2）自定义数据格式：在数据中放入开始、结束标识；解析时根据格式抓取数据，缺点是数据内不能含有开始或结束标识；
######（3）短连接传输，建立一次连接只传输一次数据就关闭；（不推荐）

### 6) OSI 的七层模型都有哪些？

1、物理层协议有：EIA/TIA-232，bai EIA/TIA-499，V.35， V.24，RJ45， Ethernet， 802.3 

2、数du据链路层协议有：Frame Relay，HDLC，PPP， IEEE 802.3/802.2

3、网络层协议有：IP，IPX，AppleTalk DDP 

4、传输zhi层协议有：TCP，UDP，SPX

5、会话层协议有：RPC，SQL，NFS，NetBIOS，names，AppleTalk

6、表示层协议有：TIFF，GIF，JPEG，PICT，ASCII，EBCDIC，encryption

7、应用层协议有：FTP，WWW，Telnet，NFS，SMTP，Gateway，SNMP

### 7) 如何实现跨域？

跨域，是指浏览器不能执行其他网站的脚本。它是由**浏览器的同源策略**造成的，是浏览器对JavaScript实施的安全限制。

1、jsonp
利用了 script 不受同源策略的限制
缺点：只能 get 方式，易受到 XSS攻击

2、CORS（Cross-Origin Resource Sharing）,跨域资源共享
当使用XMLHttpRequest发送请求时，如果浏览器发现违反了同源策略就会自动加上一个请求头 origin；
后端在接受到请求后确定响应后会在后端在接受到请求后确定响应后会在 Response Headers 中加入一个属性 Access-Control-Allow-Origin；
浏览器判断响应中的 Access-Control-Allow-Origin 值是否和当前的地址相同，匹配成功后才继续响应处理，否则报错
缺点：忽略 cookie，浏览器版本有一定要求

3、代理跨域请求
前端向发送请求，经过代理，请求需要的服务器资源
缺点：需要额外的代理服务器

4、Html5 postMessage 方法
允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本、多窗口、跨域消息传递
缺点：浏览器版本要求，部分浏览器要配置放开跨域限制

5、修改 document.domain 跨子域
相同主域名下的不同子域名资源，设置 document.domain 为 相同的一级域名
缺点：同一一级域名；相同协议；相同端口

6、基于 Html5 websocket 协议
websocket 是 Html5 一种新的协议，基于该协议可以做到浏览器与服务器全双工通信，允许跨域请求
缺点：浏览器一定版本要求，服务器需要支持 websocket 协议

7、document.xxx + iframe
通过 iframe 是浏览器非同源标签，加载内容中转，传到当前页面的属性中
缺点：页面的属性值有大小限制

### 8) 说一下 JSONP 实现原理？

javascript相关的

首先在客户端注册一个callback，然后把callback的名字传给服务器。此时，服务器先生成json数据，然后以javascript语法的方式，生成function，function名字就是传递上来I带参数jsonp。最后将json数据直接以入参的方式，放置function中，这样就生成js语法的文档，返回给客户端。客户端浏览器，解析script变迁，并执行返回javascript文档，此时数据作为参数，传入了客户端预先定义好的callback函数里。简单的说，就是利用script标签没有跨域限制的“漏洞”来达到与第三方通讯的目的。

## 9、设计模式

### 1) 说一下你熟悉的设计模式？

### 2) 简单工厂和抽象工厂有什么区别？

## 10、Spring / SpringMVC

## 11、Spring boot / Spring Cloud

## 12、Hibernate / JPA

## 13、Mybatis

## 14、RabbitMQ

## 15、Kafak

## 16、 Zookeeper

## 17、Mysql

## 18、Redis

## 19、JVM



# 二、应用题

## 1、单例模式
### 1)、简单的单例模式-饿汉式
* 需要一个私有的当前对象属性
* 私有化构造方法
* 返回当前对象的静态方法
```java
public class Singleton1 {
    // 需要一个私有的属性
    private static  Singleton1 instance = new Singleton1();
    // 私有化构造方法
    private Singleton1(){
    }
    // 静态返回 
    public static Singleton1 getInstance(){
        return instance;
    }
}
```
注意：
* 通过反射获取的对象不是同一个对象
* 通过代理对象获取的对象不是同一个对象
* 通过反序列化获取的对象不是同一个对象，但可以通过加入如下方法解决
```java
public class Singleton1{
    // ......
    /**
     * 加入这个方法后，序列化的过程中会会保存当前属性
     * 在反序列化的时候就会把当前对象也给得到
     * @return
     */
    public Object readResolve() {
        return instance;
    }
}
```

### 2)、登记式
- 登记式是对饿汉试的扩展
- 通过反射创建的时候是安全的
- 只有在调用 getInstance() 才会去加载 ins 对象实例
```java
public class Singleton1 {
    private static class SingletonHolder {
        private static Singleton1 ins = new Singleton1();
    }
    private Singleton1(){}
    /**
     * 只有在这个方法被调用的时候，才会加载 ins 实例
     * @return
     */
    public static Singleton1 getInstance(){
        return SingletonHolder.ins;
    }
}
```
### 3)、枚举式
- 目前最好的单例
- 线程安全的，并可以防止反射
- 高效

代码
```java
/**
 * 创建一个枚举类型
 */
public enum Singleton3 {

    INSTANCE {
        @Override
        protected void doSomething() {
            System.out.println("doSomething");
        }
    };
    //
    protected abstract void doSomething();
}
```
使用：
```java
public class Singletion1Test {
    @Test
    public void test1(){
        Singleton1 s1 = Singleton1.getInstance();
        Singleton1 s2 = Singleton1.getInstance();
        System.out.println(s1);
        System.out.println(s2);
        System.out.println(s1.equals(s2));
    }
    @Test
    public void test2(){
        Singleton3 s1 = Singleton3.INSTANCE;
        Singleton3 s2 = Singleton3.INSTANCE;
        System.out.println(s1);
        System.out.println(s2);
        System.out.println(s1.equals(s2));
    }
}
```
缺点：枚举类型没有办法实现继承

### 4)、懒汉式

-  不是线程安全的
```java
public class Singleton4 {
    private static Singleton4 ins = null;
    private Singleton4(){
    }
    public static Singleton4 getInstance(){
        if (ins == null) {
            ins = new Singleton4();
        }
        return ins;
    }
}
```
修改懒汉式，让它变成线程安全
```java
public class Singleton5 {
    private static Singleton5 ins = null;
    private Singleton5(){
    }
    // 加入 synchronized 
    public static synchronized Singleton5 getInstance(){
        if (ins == null) {
            ins = new Singleton5();
        }
        return ins;
    }
}
```
这样写就可以保证效率
```java
package top.aoae.job.singleton;
public class Singleton7 {
    private static Singleton7 ins = null;
    private Singleton7(){
    }
    public static Singleton7 getInstance(){
        if (ins == null) {
            // 这样写，速度就会变快
            synchronized (Singleton7.class) {
                if (ins == null) {
                    ins = new Singleton7();
                }
            }
        }
        return ins;
    }
}
```

### 5)、使用ThradLocal的单例模式

```java
public class Singleton8 {
    private static Singleton8 instance = null;
    private Singleton8(){}
    // 可以保证在同一个线程里拿到的对象是单例的
    // 不能保证在不同的线程里拿到的的对象是不是单例的
    private static final ThreadLocal<Singleton8> threadLocalSinglet = 
      new ThreadLocal<Singleton8>(){
        @Override
        protected Singleton8 initialValue() {
            return new Singleton8();
        }
    };
    private static Singleton8 getInstance(){
        return threadLocalSinglet.get();
    }
}
```

### 6)、CAS单例模式

- 利用AtomicReference实现

```java
public class Singleton9 {
    private static final AtomicReference<Singleton9> instance =
            new AtomicReference<>();
    private Singleton9(){}
    private static final Singleton9 getInstance(){
        for(;;){ // 重试
            Singleton9 current = instance.get();
            if (current != null) {
                return current;
            }
            current = new Singleton9();
            if (instance.compareAndSet(null, current)) {
                return current;
            }
        }
    }
}
```

## 2、Exception和Error

### 1)、Exception和Error的区别?

Exception和Error都继承于Throwable，只有Throwable派生出来的子类，才可以抛出。

Error是程序运行过程中不太可能出现的异常，当它出现的时候程序就会崩溃。不能通过捕获异常来恢复。如：`OurOfMemoryError`、`StackOverflowError`

Exception是程序运行中可以预料意外的况，可以捕获的异常。

### 2)、运行时异常和一般异常的区别

受检查异常，在编译时被强制检查的异常。在方法的声明中声明的异常如：`ClassNotFoundException`、`IOException`

 不受检查的异常：不受检查异常通常在编码中可以避免的逻辑错误，根据需求来判断如何处理，不需要再编译期强制要求

### 3)、写出几个常见的运行时异常

运行时异常`RuntimeException`是所有不受检查异常的基类

`NullPointerExceptio`、`ClassCastException`、`NumberFormatException`、`IndexOutOfBoundsException`

### 4)、ClassNotFoundException和NoClassDefFoundError区别？

ClassNotFoundException，当应用程序运行过程中尝试使用类加载器去加载Class文件的时候，如果没有在classpath中查找到指定的类，就会抛出这个异常

NoClassDefFoundError 当JVM在加载一个类的时候，如果这个类在编译时是可用的，但在运行时没有找到这个类的时候，JVM就会抛出这个错误

从名字可以看出ClassNotFoundException继承于Exception，NoClassDefFoundError继承于Error，所以NoClassDefFoundError不能被捕获。

### 5)、Throw和Throws的区别？

Throw是在方法体内手动抛出的异常，一次只能抛出一个异常，由方法体处理，如果方法体内不处理，则需要在方法上声明throws

Throws是在方法声明时，表明该方法可能产生的所有异常，不做任何直接处理向上层传

### 6)、你对异常有什么了解?

- 尽量不要捕获Exception这种异常，尽量精确捕获异常。
- 直接打印一个异常不是一个很好的选择，最好能把异常信息输出到日志上
- 尽量不要使用try{....}catch{}包裹一个大的代码片段，这很产生额外的性能开销
- 捕获异常最好要输出，不要什么都不处理

### 7)、int和Integer的区别？

- int是整形，是java的8种基本类型之一
- Integer是int的包装类型，它有一个final的修饰的int字段，并提供了数学运行算、字int和字符串之间转换等常用的方法
- Integer和String一样，也是不可变类型。
- 看源码可发现，在java5后，valueOf方法使用了一个缓存机制，默认缓存是-128-127；在创建这个范围的整数时，不需要new新对象，而是使用缓存，提高性能；如不在这个范围时，就会创建出一个新的对象，所以Integer类型如果不在这个范围，不能使用==运算符比较。
- 缓存在Boolean、Short、Byte和Character中同样存在
- 把基本数据类型转换成包装类型是**装箱**，把包装类型转成基本类型是**拆箱**。
- Java中有自动装箱和拆箱的功能。但在性能敏感的场合尽量不要使用
- int基本类型不使用和泛型结合使用。

## 3、基本算法

### 1)、实现大数的加数(1000位)

String a = "123456...." a.size 大于1000位

String b = "123456...." b.size大于1000位

```java
public class Test {

    /**
     * 两个超大的数字(1000位以上)求和
     */
    @org.junit.Test
    public void test1(){
        String a = "10001";
        String b = "99999999";
        char[] large = null; // 用于保存大的数
        char[] small = null; // 用于保存小的数
        if (a.length() >= b.length()) {
            large = a.toCharArray();
            small = b.toCharArray();
        } else {
            large = b.toCharArray();
            small = a.toCharArray();
        }
        int [] sums = new int[large.length + 1];
        for(int i=0;i<large.length;i++){
          	// 把大的数字，从个位开始，写入到 sums 中
            sums[i] = large[large.length - i - 1] - '0';
        }
        for(int i=0;i<small.length;i++){
          	// 对 sums 中每个元素进行加
            sums[i] += small[small.length - i - 1]- '0';
        }

        for (int i=0;i<sums.length-1;i++){
            if (sums[i] > 9) {
                sums[i + 1] += sums[i] / 10; // 进一位， 也可以 += 1
                sums[i] %= 10;
            }
        }

        StringBuilder stringBuilder = new StringBuilder();
        for(int i=sums.length -1; i>=0; i--){
            stringBuilder.append(sums[i]);
        }
        String result = stringBuilder.toString();
        if (result.startsWith("0")){
            result = result.substring(1);
        }

        System.out.println(result);
    }
}
```

### 2)、找出字符串中出现最多的字符

```java
public class Test {
    /**
     * 找出字符串中出现最多的字符
     */
    @org.junit.Test
    public void test3() {
        String str = "abcdefgabcdfgabcceedf";
        Map<Character, Integer> map = new HashMap<>();
        int max = 0;
        char result = str.charAt(0);
        for(int i=0;i<str.length();i++) {
            char c = str.charAt(i);
            Integer count = map.get(c);
            count = count == null ? 1 : count + 1;

            map.put(c, count);

            if(count > max) {
                result = c;
                max = count;
            }
        }
        System.out.println(result + "出现次数最多:" + max);
    }

}
```

### 3)找出字符串中第一次重复出现的字符

```java
	@org.junit.Test
    public void test4(){
        String str = "abccba";
        Set<Character> set = new HashSet<>();
        for (int i = 0; i < str.length(); i++) {
            if(set.add(str.charAt(i)) == false){
                System.out.println(str.charAt(i));
                break;
            }
        }
    }
```

### 4)、找出字符串中第一个只出现一次的字符

```java
@org.junit.Test
    public void test5(){
        String str = "abcabcdeab";
        // 方法1，使用map统计
        Map<Character, Integer> map = new HashMap<>();
        for(int i=0;i<str.length();i++) {
            char c = str.charAt(i);
            Integer count = map.get(c);
            count = count == null ? 1 : count + 1;
            map.put(c, count);
        }
        for (int i = 0; i < str.length(); i++) {
            if(map.get(str.charAt(i)) == 1) {
                System.out.println(str.charAt(i));
                break;
            }
        }

        // 方法2，使用字符串相关函数
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            // 因为只有一个字符，所以最后出现的位置和开始出现的位置是一样的
            if(str.indexOf(c) == str.lastIndexOf(c)){
                System.out.println(c);
                break;
            }
        }
    }
```

### 5)、按字节数截取字符串

```java
 @org.junit.Test
    public void test7(){
        String str = "人ABC们DEF";
        int count = 4; // 需要截取的字节数
        int sum=0;
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < str.length(); i++) {
          	// 获取当前字符所占用的字节数，中文(utf-8编码下占用3个字节)和英文是不一样的
            int len = String.valueOf(str.charAt(i)).getBytes().length;
            if(sum + len <= count){
                sum += len;
                builder.append(str.charAt(i));
            }else{
                break;
            }
        }
        System.out.println(builder.toString());
    }
```

### 5)、字符串反转

```java
@org.junit.Test
    public void test8(){
        String src = "abcdefg";

        // 方法一，使用StringBuilder
        StringBuilder builder = new StringBuilder(src);
        System.out.println(builder.reverse());

        // 方法二
        StringBuilder des = new StringBuilder();
        for (int i = src.length() - 1; i >=0; i--) {
            des.append(src.charAt(i));
        }
        System.out.println(des.toString());

        // 方法三
        char[] chars = src.toCharArray();
        for (int i = 0; i < chars.length / 2; i++) {
            char tmp = chars[i];
            chars[i] = chars[chars.length-i-1];
            chars[chars.length-i-1] = tmp;
        }
        System.out.println(new String(chars));
    }
```

### 6)、对换句子中的单词位置

```java
    @org.junit.Test
    public void test9(){
        String str = "I love this";
        String[] strs = str.split(" ");
        StringBuilder builder = new StringBuilder();
        for (int i = strs.length - 1; i >=0 ; i--) {
            builder.append(strs[i]);
            builder.append(" ");
        }
        System.out.println(builder.toString().trim());
    }
```

