





# 一、常见题

## 1、java基础

### 1) JDK、JRE和JVM有什么区别？

**JDK**：Java Development Kit 是Java的标准开发工具包（普通用户只需要安装 JRE来运行 Java 程序。而程序开发者必须安装JDK来编译、调试程序）。它提供了编译、运行Java程序所需的各种工具和资源，包括Java编译器、Java运行环境JRE，以及常用的Java基础类库等，是整个JAVA的核心。

**JRE**：Java runtime environment 是运行基于Java语言编写的程序所不可缺少的运行环境，用于解释执行Java的字节码文件。

**JVM**：Java Virtual Machine 是Java的虚拟机，是JRE的一部分。它是整个java实现跨平台的最核心的部分，负责解释执行字节码文件，是可运行java字节码文件的虚拟计算机。

### 2) == 和 equals 的区别是什么？

- **"=="是比较运算符**，判断两个变量bai或实例du是不是指向zhi同一个内存空间。
- **"equals"是类方法(可重写)**，判断两个变量或实例所指向的内存空间的值是不是相同

### 3) 两个对象的 hashCode()相同，则 equals()也一定为 true，对吗?

答：否。hashCode()和equals没有必然的联系。但重定hashCode或equals需要满足一些规范。

> 1 hashCode和equals返回值应该是稳定的，不应用有随机性
>
> 2 两个对象 == 返回 true，则这两个对象的equals应该返回true
>
> 3 两个对象equals为true，则这两个对象的hashCode应该相等。

反之，两个对象 equals 为 true，两个对象的hashCode() 相等

### 4) final 在 java 中有什么作用?

- 修饰类：表示该类不能被继承；

- 修饰方法：表示方法不能被重写；
- 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。

 ### 5) java 中的 Math.round(-1.5) 等于多少？

四舍五入的原理是在参数上加0.5然后做向下取整，答案：-1

### 6) String 属于基础的数据类型吗？

Java 中 8 种基础的数据类型：byte、short、char、int、long、float、double、boolean

但是 String 类型却是最常用到的引用类型

### 7) java 中操作字符串都有哪些类？它们之间有什么区别？

String、StringBuffer、StringBuilder

**String** : final修饰，String类的方法都是返回new String。即对String对象的任何改变都不影响到原对象，对字符串的修改操作都会生成新的对象。

**StringBuffer** : 对字符串的操作的方法都加了synchronized，保证线程安全。

**StringBuilder** : 不保证线程安全，在方法体内需要进行字符串的修改操作，可以new StringBuilder对象，调用StringBuilder对象的append、replace、delete等方法修改字符串。

### 8) String str="i"与 String str=new String(“i”)一样吗？

`String str="i"`的方式，Java 虚拟机会将其分配到<b style="color:deeppink;">常量池</b>中，而常量池中没有重复的元素，比如当执行`“i”`时，java虚拟机会先在<b style="color:deeppink;">常量池</b>中检索是否已经有`“i”`,如果有那么就将`“i”`的<b style="color:deeppink;">地址赋给变量</b>，如果没有就创建一个，然后在赋给变量；而 `String str = new String(“i”)` 则会被分到<b style="color:deeppink;">堆内存</b>中，<u>即使内容一样还是会创建新的对象</u>。

### 9) 如何将字符串反转？

```java
String str = "abcdefg";
// 方法一
StringBuilder builder = new StringBuilder(str);
System.out.println(builder.reverse());

// 方法二
StringBuilder builder = new StringBuilder();
for(int i=str.length-1; i >= 0; i--){
  builder.append(str.charAt(i))
}
System.out.println(builder.toString());

// 方法三
char[] chars = src.toCharArray();
for (int i = 0; i < chars.length / 2; i++) {
  char tmp = chars[i];
  chars[i] = chars[chars.length-i-1];
  chars[chars.length-i-1] = tmp;
}
System.out.println(new String(chars));
```

### 10) String 类的常用方法都有那些？

* indexOf 返回指定字符的索引
* charAt 返回指定索引处的字符
* replace 字符串替换
* trim 去除字符串两端的空白 
* Split 分割字符串
* getBytes 返回字符串的byte类型数组
* Substring 字符串截取
* equals 字符串比较
* length 字符串长度
* toLowerCase 转小写
* toUpperCase 转大写

### 11) 抽象类必须要有抽象方法吗？

不是必须的。

1. 抽象类必须有关键字abstract来修饰。
2. 抽象类可以不含有抽象方法
3. 如果一个类包含抽象方法，则该类必须是抽象类

### 12) 普通类和抽象类有哪些区别？

1. 抽象类不能被实例化
2. 抽象类可以有抽象方法，抽象方法只需声明，不用实现
3. 含有抽象方法的类型必须声明为抽象类
4. 抽象类的子类必须实现抽象方法，否则类的子类也是抽象类
5. 抽象方法不能用private修饰
6. 抽象方法不能使用final修饰
7. 抽象方法不能声明为静态

### 13) 接口和抽象类有什么区别？

1. 抽象类要被子类继承，接口要被类实现。

2. 接口只能做方法声明，抽象类中可以作方法声明，也可以做方法实现。

3. 接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。

4. 接口是设计的结果，抽象类是重构的结果。

5. 抽象类和接口都是用来抽象具体对象的，但是接口的抽象级别最高。

6. 抽象类可以有具体的方法和属性，接口只能有抽象方法和不可变常量。

7. 抽象类主要用来抽象类别，接口主要用来抽象功能。

### 14) java 中 IO 流分为几种？

- 按照流的流向分，可以分为输入流和输出流；
- 按照操作单元划分，可以划分为字节流和字符流；
- 按照流的角色划分为节点流和处理流。

### 15) Files的常用方法都有哪些？

- exists 判断文件是否存在
- createDirectory 创建目录
- copy 复制文件
- move  移动文件
- delete 删除文件
- deleteIfExists 删除一个文件或目录(空目录)，如果存在就删除

### 16) BIO、NIO、AIO 有什么区别？

**BIO(同步并阻塞)**，<b style="color:deeppink;">服务器实现模式为一个连接一个线程</b>，即客户端连接请求时服务端就需要启动一个线程来处理，如果这个连接不做任何事会造成不必要的线程开销，当然可以通过线程池机制改善。<i style="color:deepskyblue;">线程发起IO请求，不管内核是否准备好IO操作，从发起请求起，线程一直阻塞，直到操作完成</i>。

**NIO(同步非阻塞)**，<b style="color:deeppink;">服务器实现模式为一个请求一个线程</b>，即客户端发送的连接请求会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。<i style="color:deepskyblue;">线程发起IO请求，立即返回；内核在做好IO操作的准备之后，通过调用注册的回调函数通知线程做IO操作，线程开始阻塞，直到操作完成</i>。

**AIO(异步非阻塞)**，<b style="color:deeppink;">服务器实现模式为一个有效请求一个线程</b>，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。<i style="color:deepskyblue;">线程发起IO请求，立即返回；内存做好IO操作的准备之后，做IO操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做IO操作完成或者失败</i>。

## 2、容器

### 1) java 集合都有哪些？

* Collection
  * List
    * ArrayList
    * LinkedList
    * Stack (线程安全)
    * Vector (线程安全)
  * Set
    * HashSet
      * 不能保证元素的排序，顺序有可能发生变化、、
      * 不是同步的
      * 集合同步
      * 集合无素可以是null但只能放入一个null
    * TreeSet
    * LinkedHashSet
* Map
  * HashMap
  * HashTable
  * ConcurrentHashMap (线程安全)
  * TreeMap

### 2) Collection 和 Collections 有什么区别？

- **Collection**是集合体系的最顶层，包含了集合体系的共性

- **Collections**是一个工具类，方法都是用于操作**Collection**

**collections**的常用方法如下：

- sort 排序
- max 集合中的最大值
- reverse 反转元素的顺序
- shuffle 随机排序

### 3) List、Set、Map 之间的区别是什么？

**List**：有序集合

**Set**：不重复集合，LinkedHashSet按照插入排序，SortedSet可排序，HashSet无序

**Map**：键值对集合

### 4) HashMap 和 Hashtable 有什么区别？

#### (1)、继承的父类不同

HashMap 和 HashTable继承的父类不一样，HashMap继承`AbstractMap`而HashTable继承自`Dictionary`。但它们都实现了`Map`、`Cloneable（可复制）`、`Serializable（可序列化）`这三个接口。

#### (2)、对外提供的接口不同

Hashtable比HashMap多提供了`elments()` 和`contains()` 两个方法。

elments() 方法继承自Hashtable的父类`Dictionnary`。elements() 方法用于返回此Hashtable中的value的枚举。

contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue() 就只是调用了一下contains() 方法。

#### (3)、对Null key 和Null value的支持不同

- **HashTable**既不支持Null key也不支持Null value。Hashtable的put()方法的注释中有说明。
- **HashMap**中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，可能是 HashMap中没有该键，也可能使该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。

#### (4)、线程安全性不同

<b style="color:deeppink;">Hashtable是线程安全的</b>，它的每个方法中都加入了Synchronize方法。在多线程并发的环境下，可以直接使用Hashtable，不需要自己为它的方法实现同步。

<b style="color:deeppink;">HashMap不是线程安全的</b>，在多线程并发的环境下，可能会产生死锁等问题。具体的原因在下一篇文章中会详细进行分析。使用HashMap时就必须要自己增加同步处理。

当需要多线程操作的时候可以使用线程安全的ConcurrentHashMap。ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为<b style="color:deeppink;">ConcurrentHashMap使用了分段锁</b>，并不对整个数据进行锁定。

#### (5)、遍历方式的内部实现上不同

Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。

#### (6)、初始容量大小和每次扩充容量大小的不同

- **HashTable**默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。

- **HashMap**默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。

#### (7)、计算hash值的方法不同

**HashTable**直接使用对象的hashCode。hashCode是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值。然后再使用除留余数发来获得最终的位置。

**HashMap**为了提高计算效率，将哈希表的大小固定为了2的幂，这样在取模预算时，不需要做除法，只需要做位运算。位运算比除法的效率要高很多。

### 5) 如何决定使用 HashMap 还是 TreeMap？

- `TreeMap<K,V>`的Key值是要求实现`java.lang.Comparable`，所以迭代的时候TreeMap默认是按照Key值升序排序的；**TreeMap的实现是基于红黑树结构**。适用于按自然顺序或自定义顺序遍历键（key）。

- `HashMap<K,V>`的Key值实现散列`hashCode()`，分布是散列的、均匀的，不支持排序；**数据结构主要是桶(数组)，链表或红黑树**。适用于在Map中插入、删除和定位元素。

  > 如果你需要得到一个有序的结果时就应该使用TreeMap（因为HashMap中元素的排列顺序是不固定的）。除此之外，由于HashMap有更好的性能，所以大多不需要排序的时候我们会使用HashMap。

### 6) 说一下 HashMap 的实现原理?



## 3、多线程

## 4、反射

## 5、对象拷贝

## 6、java web

## 7、异常

## 8、网络

## 9、设计模式

## 10、Spring/SpringMVC

## 11、Spring boot / Spring Cloud

## 12、Hibernate

## 13、Mybatis

## 14、RabbitMQ

## 15、Kafak

## 16、 Zookeeper

## 17、Mysql

## 18、Redis

## 19、JVM



# 二、应用题

## 1、单例模式
### 1)、简单的单例模式-饿汉式
* 需要一个私有的当前对象属性
* 私有化构造方法
* 返回当前对象的静态方法
```java
public class Singleton1 {
    // 需要一个私有的属性
    private static  Singleton1 instance = new Singleton1();
    // 私有化构造方法
    private Singleton1(){
    }
    // 静态返回 
    public static Singleton1 getInstance(){
        return instance;
    }
}
```
注意：
* 通过反射获取的对象不是同一个对象
* 通过代理对象获取的对象不是同一个对象
* 通过反序列化获取的对象不是同一个对象，但可以通过加入如下方法解决
```java
public class Singleton1{
    // ......
    /**
     * 加入这个方法后，序列化的过程中会会保存当前属性
     * 在反序列化的时候就会把当前对象也给得到
     * @return
     */
    public Object readResolve() {
        return instance;
    }
}
```

### 2)、登记式
- 登记式是对饿汉试的扩展
- 通过反射创建的时候是安全的
- 只有在调用 getInstance() 才会去加载 ins 对象实例
```java
public class Singleton1 {
    private static class SingletonHolder {
        private static Singleton1 ins = new Singleton1();
    }
    private Singleton1(){}
    /**
     * 只有在这个方法被调用的时候，才会加载 ins 实例
     * @return
     */
    public static Singleton1 getInstance(){
        return SingletonHolder.ins;
    }
}
```
### 3)、枚举式
- 目前最好的单例
- 线程安全的，并可以防止反射
- 高效

代码
```java
/**
 * 创建一个枚举类型
 */
public enum Singleton3 {

    INSTANCE {
        @Override
        protected void doSomething() {
            System.out.println("doSomething");
        }
    };
    //
    protected abstract void doSomething();
}
```
使用：
```java
public class Singletion1Test {
    @Test
    public void test1(){
        Singleton1 s1 = Singleton1.getInstance();
        Singleton1 s2 = Singleton1.getInstance();
        System.out.println(s1);
        System.out.println(s2);
        System.out.println(s1.equals(s2));
    }
    @Test
    public void test2(){
        Singleton3 s1 = Singleton3.INSTANCE;
        Singleton3 s2 = Singleton3.INSTANCE;
        System.out.println(s1);
        System.out.println(s2);
        System.out.println(s1.equals(s2));
    }
}
```
缺点：枚举类型没有办法实现继承

### 4)、懒汉式

-  不是线程安全的
```java
public class Singleton4 {
    private static Singleton4 ins = null;
    private Singleton4(){
    }
    public static Singleton4 getInstance(){
        if (ins == null) {
            ins = new Singleton4();
        }
        return ins;
    }
}
```
修改懒汉式，让它变成线程安全
```java
public class Singleton5 {
    private static Singleton5 ins = null;
    private Singleton5(){
    }
    // 加入 synchronized 
    public static synchronized Singleton5 getInstance(){
        if (ins == null) {
            ins = new Singleton5();
        }
        return ins;
    }
}
```
这样写就可以保证效率
```java
package top.aoae.job.singleton;
public class Singleton7 {
    private static Singleton7 ins = null;
    private Singleton7(){
    }
    public static Singleton7 getInstance(){
        if (ins == null) {
            // 这样写，速度就会变快
            synchronized (Singleton7.class) {
                if (ins == null) {
                    ins = new Singleton7();
                }
            }
        }
        return ins;
    }
}
```

### 5)、使用ThradLocal的单例模式

```java
public class Singleton8 {
    private static Singleton8 instance = null;
    private Singleton8(){}
    // 可以保证在同一个线程里拿到的对象是单例的
    // 不能保证在不同的线程里拿到的的对象是不是单例的
    private static final ThreadLocal<Singleton8> threadLocalSinglet = 
      new ThreadLocal<Singleton8>(){
        @Override
        protected Singleton8 initialValue() {
            return new Singleton8();
        }
    };
    private static Singleton8 getInstance(){
        return threadLocalSinglet.get();
    }
}
```

### 6)、CAS单例模式

- 利用AtomicReference实现

```java
public class Singleton9 {
    private static final AtomicReference<Singleton9> instance =
            new AtomicReference<>();
    private Singleton9(){}
    private static final Singleton9 getInstance(){
        for(;;){ // 重试
            Singleton9 current = instance.get();
            if (current != null) {
                return current;
            }
            current = new Singleton9();
            if (instance.compareAndSet(null, current)) {
                return current;
            }
        }
    }
}
```

## 2、Exception和Error

### 1)、Exception和Error的区别?

Exception和Error都继承于Throwable，只有Throwable派生出来的子类，才可以抛出。

Error是程序运行过程中不太可能出现的异常，当它出现的时候程序就会崩溃。不能通过捕获异常来恢复。如：`OurOfMemoryError`、`StackOverflowError`

Exception是程序运行中可以预料意外的况，可以捕获的异常。

### 2)、运行时异常和一般异常的区别

受检查异常，在编译时被强制检查的异常。在方法的声明中声明的异常如：`ClassNotFoundException`、`IOException`

 不受检查的异常：不受检查异常通常在编码中可以避免的逻辑错误，根据需求来判断如何处理，不需要再编译期强制要求

### 3)、写出几个常见的运行时异常

运行时异常RuntimeException是所有不受检查异常的基类

`NullPointerExceptio`、`ClassCastException`、`NumberFormatException`、`IndexOutOfBoundsException`

### 4)、ClassNotFoundException和NoClassDefFoundError区别？

ClassNotFoundException，当应用程序运行过程中尝试使用类加载器去加载Class文件的时候，如果没有在classpath中查找到指定的类，就会抛出这个异常

NoClassDefFoundError 当JVM在加载一个类的时候，如果这个类在编译时是可用的，但在运行时没有找到这个类的时候，JVM就会抛出这个错误

从名字可以看出ClassNotFoundException继承于Exception，NoClassDefFoundError继承于Error，所以NoClassDefFoundError不能被捕获。

### 5)、Throw和Throws的区别？

Throw是在方法体内手动抛出的异常，一次只能抛出一个异常，由方法体处理，如果方法体内不处理，则需要在方法上声明throws

Throws是在方法声明时，表明该方法可能产生的所有异常，不做任何直接处理向上层传

### 6)、你对异常有什么了解?

- 尽量不要捕获Exception这种异常，尽量精确捕获异常。
- 直接打印一个异常不是一个很好的选择，最好能把异常信息输出到日志上
- 尽量不要使用try{....}catch{}包裹一个大的代码片段，这很产生额外的性能开销
- 捕获异常最好要输出，不要什么都不处理

### 7)、int和Integer的区别？

- int是整形，是java的8种基本类型之一
- Integer是int的包装类型，它有一个final的修饰的int字段，并提供了数学运行算、字int和字符串之间转换等常用的方法
- Integer和String一样，也是不可变类型。
- 看源码可发现，在java5后，valueOf方法使用了一个缓存机制，默认缓存是-128-127；在创建这个范围的整数时，不需要new新对象，而是使用缓存，提高性能；如不在这个范围时，就会创建出一个新的对象，所以Integer类型如果不在这个范围，不能使用==运算符比较。
- 缓存在Boolean、Short、Byte和Character中同样存在
- 把基本数据类型转换成包装类型是**装箱**，把包装类型转成基本类型是**拆箱**。
- Java中有自动装箱和拆箱的功能。但在性能敏感的场合尽量不要使用
- int基本类型不使用和泛型结合使用。

## 3、基本算法

### 1)、实现大数的加数(1000位)

String a = "123456...." a.size 大于1000位

String b = "123456...." b.size大于1000位

```java
public class Test {

    /**
     * 两个超大的数字(1000位以上)求和
     */
    @org.junit.Test
    public void test1(){
        String a = "10001";
        String b = "99999999";
        char[] large = null; // 用于保存大的数
        char[] small = null; // 用于保存小的数
        if (a.length() >= b.length()) {
            large = a.toCharArray();
            small = b.toCharArray();
        } else {
            large = b.toCharArray();
            small = a.toCharArray();
        }
        int [] sums = new int[large.length + 1];
        for(int i=0;i<large.length;i++){
          	// 把大的数字，从个位开始，写入到 sums 中
            sums[i] = large[large.length - i - 1] - '0';
        }
        for(int i=0;i<small.length;i++){
          	// 对 sums 中每个元素进行加
            sums[i] += small[small.length - i - 1]- '0';
        }

        for (int i=0;i<sums.length-1;i++){
            if (sums[i] > 9) {
                sums[i + 1] += sums[i] / 10; // 进一位， 也可以 += 1
                sums[i] %= 10;
            }
        }

        StringBuilder stringBuilder = new StringBuilder();
        for(int i=sums.length -1; i>=0; i--){
            stringBuilder.append(sums[i]);
        }
        String result = stringBuilder.toString();
        if (result.startsWith("0")){
            result = result.substring(1);
        }

        System.out.println(result);
    }
}
```

### 2)、找出字符串中出现最多的字符

```java
public class Test {
    /**
     * 找出字符串中出现最多的字符
     */
    @org.junit.Test
    public void test3() {
        String str = "abcdefgabcdfgabcceedf";
        Map<Character, Integer> map = new HashMap<>();
        int max = 0;
        char result = str.charAt(0);
        for(int i=0;i<str.length();i++) {
            char c = str.charAt(i);
            Integer count = map.get(c);
            count = count == null ? 1 : count + 1;

            map.put(c, count);

            if(count > max) {
                result = c;
                max = count;
            }
        }
        System.out.println(result + "出现次数最多:" + max);
    }

}
```

### 3)找出字符串中第一次重复出现的字符

```java
	@org.junit.Test
    public void test4(){
        String str = "abccba";
        Set<Character> set = new HashSet<>();
        for (int i = 0; i < str.length(); i++) {
            if(set.add(str.charAt(i)) == false){
                System.out.println(str.charAt(i));
                break;
            }
        }
    }
```

### 4)、找出字符串中第一个只出现一次的字符

```java
@org.junit.Test
    public void test5(){
        String str = "abcabcdeab";
        // 方法1，使用map统计
        Map<Character, Integer> map = new HashMap<>();
        for(int i=0;i<str.length();i++) {
            char c = str.charAt(i);
            Integer count = map.get(c);
            count = count == null ? 1 : count + 1;
            map.put(c, count);
        }
        for (int i = 0; i < str.length(); i++) {
            if(map.get(str.charAt(i)) == 1) {
                System.out.println(str.charAt(i));
                break;
            }
        }

        // 方法2，使用字符串相关函数
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            // 因为只有一个字符，所以最后出现的位置和开始出现的位置是一样的
            if(str.indexOf(c) == str.lastIndexOf(c)){
                System.out.println(c);
                break;
            }
        }
    }
```

### 5)、按字节数截取字符串

```java
 @org.junit.Test
    public void test7(){
        String str = "人ABC们DEF";
        int count = 4; // 需要截取的字节数
        int sum=0;
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < str.length(); i++) {
          	// 获取当前字符所占用的字节数，中文(utf-8编码下占用3个字节)和英文是不一样的
            int len = String.valueOf(str.charAt(i)).getBytes().length;
            if(sum + len <= count){
                sum += len;
                builder.append(str.charAt(i));
            }else{
                break;
            }
        }
        System.out.println(builder.toString());
    }
```

### 5)、字符串反转

```java
@org.junit.Test
    public void test8(){
        String src = "abcdefg";

        // 方法一，使用StringBuilder
        StringBuilder builder = new StringBuilder(src);
        System.out.println(builder.reverse());

        // 方法二
        StringBuilder des = new StringBuilder();
        for (int i = src.length() - 1; i >=0; i--) {
            des.append(src.charAt(i));
        }
        System.out.println(des.toString());

        // 方法三
        char[] chars = src.toCharArray();
        for (int i = 0; i < chars.length / 2; i++) {
            char tmp = chars[i];
            chars[i] = chars[chars.length-i-1];
            chars[chars.length-i-1] = tmp;
        }
        System.out.println(new String(chars));
    }
```

### 6)、对换句子中的单词位置

```java
    @org.junit.Test
    public void test9(){
        String str = "I love this";
        String[] strs = str.split(" ");
        StringBuilder builder = new StringBuilder();
        for (int i = strs.length - 1; i >=0 ; i--) {
            builder.append(strs[i]);
            builder.append(" ");
        }
        System.out.println(builder.toString().trim());
    }
```

