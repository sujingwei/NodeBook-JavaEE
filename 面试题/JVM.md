# 一、JDK体系结构

![jdk体系结构](http://notebook-1.aoae.top/15991959213634)

## 1、什么是jvm虚拟机？

![什么是jvm虚拟机](http://notebook-1.aoae.top/15991984404739)

## 2、jvm虚拟机由3部分组成：

* 类装载器
* 运行时数据区(Jvm内存模型)
* 字节码执行引擎

# 一、栈

栈，就在程序在运行过程中<i style="color:deeppink;">用于存放线程的局部变量的内存空间</i>。<u>它会给每一个线程分配一个不同的空间</u>。

![](http://notebook-1.aoae.top/15997163987649)

## 栈帧

**栈帧也叫过程活动记录**，是编译器用来实现过程/函数调用的一种数据结构。栈桢，每个方法对应的内存区域就是栈桢。

栈桢之间怎么通信？

### 1、局部变量表

### 2、操作数栈

### 3、动态连接

### 4、方法出口



# 二、方法区

方法区主要存放常量、静态变量、类元信息等数据。如果静态变量也是通过new得到的一个对象，那么这个静态变量最终的值也是在堆里得到的。

# 三、本地方法栈

本地方法栈(Native Method Stacks)与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用Native方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机(譬如un HotSpot虚拟机)直接就把本地方法栈和虚拟机合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。

# 四、程序计数器

## 1、什么是程序计数器

<b style="color:deeppink;">程序计数器是一个记录着当前线程所执行的字节码的行号指示器</b>。

JAVA代码编译后的字节码在未经过JIT（实时编译器）编译前，其执行方式是通过“字节码解释器”进行解释执行。简单的工作原理为解释器读取装载入内存的字节码，按照顺序读取字节码指令。读取一个指令后，将该指令“翻译”成固定的操作，并根据这些操作进行分支、循环、跳转等流程。

　　从上面的描述中，可能会产生程序计数器是否是多余的疑问。因为沿着指令的顺序执行下去，即使是分支跳转这样的流程，跳转到指定的指令处按顺序继续执行是完全能够保证程序的执行顺序的。假设程序永远只有一个线程，这个疑问没有任何问题，也就是说并不需要程序计数器。但实际上程序是通过多个线程协同合作执行的。

　　首先我们要搞清楚JVM的多线程实现方式。JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，在JVM中，通过程序计数器来记录某个线程的字节码执行位置。因此，<b style="color:deeppink;">程序计数器是具备线程隔离的特性</b>，也就是说，<b style="color:deeppink;">每个线程工作时都有属于自己的独立计数器</b>。

## 2、程序计数器的特点

1. 线程隔离性，每个线程工作时都有属于自己的独立计数器。
2. 执行java方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址（参考上一小节的描述）。
3. 执行native本地方法时，程序计数器的值为空（Undefined）。因为native方法是java通过JNI直接调用本地C/C++库，可以近似的认为native方法相当于C/C++暴露给java的一个接口，java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++而不是java进行实现。那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。

4. 程序计数器占用内存很小，在进行JVM内存计算时，可以忽略不计。

5. 程序计数器，是唯一一个在java虚拟机规范中没有规定任何`OutOfMemoryError`的区域。

# 五、堆

![](http://notebook-1.aoae.top/15999607041922)

新**new**出来的对象，会放在<span style="color:deeppink;">Eden</span>区。如果<span style="color:deeppink;">Eden</span>被放满，那么就会调用<span style="color:deeppink;">minor gc</span>回收<span style="color:deeppink;">Eden</span>区中无效的，没有被引用的对象(垃圾对象)。

**什么是垃圾对象？**

在说明什么是垃圾对象的情况下必需先讲什么是<span style="color:deeppink;">GC Roots根节点</span>?

![](http://notebook-1.aoae.top/15998068591746)

当某个方法执行完毕后，它对应的栈内存会被回收。这个时候，保存在局部变量表中的指向引用对象的变量也会被回收(如上图)。这个时候存放在<b style="color:deeppink;">堆</b>里的对象，因为失去了<span style="color:deeppink;">GC Roots根节点</span>。就变成了**垃圾对象**。

<span style="color:deeppink;">minor gc</span>，遍历**栈**、**方法区**里定义的变量/常量，确定出年轻代Eden区哪些对象已失去了<span style="color:deeppink;">GC Roots根节点</span>，那么就删除这些对象。

